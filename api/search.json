[{"id":"c8cfae81d0221a7bdc286aee2fff1709","title":"Bitcoin 白皮书阅读手记","content":"Related Knowledge\n\n\n\n\n\n\n\n\n\n双重支出\n\n在传统的现金交易中，货币在支付后就彻底离手了，不可能再次被拿来使用。\n在中心化数字交易中，“货币离手”这件事由受信任的第三方机构（例如银行、支付宝）保证。\n在去中心化数字交易中，如果没有一套机制保证这件事，则支付者可以将同样的数字货币用于好几笔交易之中，导致“双重支出”，进而损害商家的权益和货币本身的信任。\n\n常见攻击方式：并行支付（一笔钱同时在好几个地方支付）、Finney 攻击（先挖出区块但不广播，交易被接受后再广播）、51%攻击（在大的区块上较难实现，控制51%的算力，直接翻身做主人）\n\n\n\n\n\n\n\n\n\n\n\n\n哈希算法（Hash，也被称为散列算法）\n代表为 SHA-256 算法，其实就是一个序列到序列的映射（一般是字符串序列），该函数是不可逆的，并且对于不同的输入序列（哪怕只有极其微小的区别），其输出也要求完全不同。如果出现了不同输入但相同输出的情形，则称为“出现了碰撞”。一般对于哈希算法的要求是能够保持较强的抗碰撞性。\n不妨把 Hash 算法理解为一种“全损压缩”，其用途是通过 Hash(A) 和 Hash(B) 是否相同来验证 A 和 B 是否相同，这里的 A 和 B 可能是两个非常长的字符串，逐个验证可能要花费很长时间，但是 Hash(A) 和 Hash(B) 则可以设计成固定的长度，比较的开销就会控制在一个限度内。\n\n\n\n\n\n\n\n\n\n\n非对称加密\n代表为 RSA 算法，需要一个公钥（对于所有人可见）和私钥（仅本人持有，若泄露则应立刻作废）。公钥加密的内容只能通过对应私钥解密，同时私钥加密的内容也只能通过对应公钥解密，比较基础的使用场景有二：\n\n加密：假设 A 希望向 B 发送一段明文 T，则他只需要使用 B 的公钥将明文加密，得到：S = RSA(T, PubKeyB)。而 B 只需要使用其私钥对其解密即可得到原始的明文：T = RSA−1(S, PriKeyB)。并且这件事只有 B 能做到，因为只有 B 拥有其私钥。\n签名 &amp; 认证：假设 A 现在希望 B 在收到上面说的密文时能知道这段消息确实是他发送的，那么只需要在信息末尾追加一段文字 T，这段文字通常是 A 的公钥，然后使用其私钥进行加密得到密文 S = RSA(S, PriKeyA) 并替换之前的明文 T，而 B 只需要用 A 的公钥解密一下这段密文，就可以知道这段信息是否是他发送的了。而其他用户无法伪造这件事，因为他们都没有 A 的私钥，且用其他公钥解密 S 都无法得到正确的明文。\n\n需要注意的是，上述加密和认证过程是基于一个前提的，也就是 B 知道 A 的公钥是什么，且确认这个公钥是 A 的，该双向确认过程由“密钥交换协议”来保证。\n\n0. 摘要 Abstract\n为了实现去中心化的点对点现金交易系统，保证隐私性、抗审查性、跨境支付便利性，必须避免对于第三方信任机构的依赖。本文提供的办法是：将交易的散列数据放进一个无长度上限、无限延展的工作证明链上，使得其在不重做的情况下就无法改变其中的某一项。其中，最长的链条用于证明已经发生的事件和顺序，也用于证明其来自于最大的算力池，只要保证绝大多数算力都是良性节点，就可以保证区块链是安全的，因为其生长速度要比攻击者更快，权威就在于快的算力池中。\n1. 介绍 Introduction\n在传统的互联网商业中，完全不可逆转的支付是不可能的，因为存在仲裁机制，且这件事会增加交易的成本。\n为了允许任意双方在不需要信任第三方的情况下直接交易，并且保障交易的安全性和交易各方的权益，需要设计一种基于加密证明而非基于信任的电子支付系统。\n2. 交易 Transactions\n我们定义一枚电子硬币为一个数字签名的链条，则当一笔转账发生时，所有人 A 需要在这个数字签名链的末尾附加以下数字签名：上一笔交易并上新所有者 B 的公钥之后的 HashCode，收款人可以通过 A 的公钥验证该数字签名链的所属权。\n\n\n然而需要注意的是，这一路径并不支持收款人验证曾经的所有者是否有人双重支付过，显然通过一个知晓每一笔交易的“铸币厂”能够完成这一需求。但是我们显然需要一种去中心化的方式，确认之前的所有者并没有在任何之前的交易上签名。\n3. 时间戳服务器 Timestamp Server\n时间戳服务器的工作方式如下：为一组记录的 hash 打上时间戳，然后将此 hash 广播出去。该被广播的时间戳能够证明这部分打包好的数据在那个时间点之前已经存在。每个时间戳都在其 hash 之中包含着之前的时间戳，因此构成了一个链条。每一个新的时间戳都一定被添加到之前的时间戳之后，是定序的。\n\n\n4. 工作证明 Proof-of-Work\n为了实现一个基于点对点的分布式时间戳服务器，我们需要使用一个工作证明系统，即寻找这样一个数值：通过某种确定的 hash 算法对其计算 hash 值之后，其 hash 值必须以一定数量的 0 开头，这将使得工作量指数级增加，而验证这一工作量的开销是固定的，只需要计算一个 hash 值即可。\n在 BTC 中，这一时间戳网络的 PoW 实现方式如下：不断尝试在区块的 hash 之后追加一个随机数，使得追加之后的结果的 hash 值以指定数量的 0 开头。一旦 CPU 的耗费算力所获得的结果满足 PoW，那么该区块链将不能再被更改，除非完成之前的所有工作量。同时，篡改某一个区块也意味着需要完成其后所有区块的工作。\n\n\n相较于常规的投票机制，例如“一个 IP 一票”，PoW 的优势在于其本质上是“一个 CPU 一票”，算力的比拼成本要比 IP 数量的比拼成本要高得多，同时也更为公平，不容易出现恶意操纵。\n如果大多数 CPU 算力都属于诚实的计算节点，那么诚实链条的增长也最为迅速，在后续部分会计算攻击者需要篡改某一区块并且追上最新进度并反超的概率。\n此外，为了应对硬件算力的不断增加，以及随着时间推进可能产生的节点参与数量变化，PoW 的难度由每小时产生的区块数量的某一移动平均值决定，两者呈负相关性。\n5. 网络 Network\n运行整个区块链网络的 Pipeline 如下：\n\n\n\n\n\n\n\n\n\n\n所有新的交易向所有节点广播；\n每个节点将新交易打包到一个区块；\n每个节点开始为此区块找一个具备难度的工作证明；\n当某个区块链找到其工作证明，它就要将此区块广播给所有节点；\n众多其他节点当且仅当以下条件被满足时才会接受该区块：其中所有的交易都是有效的，并且不存在双重支付；\n众多节点向网络标识自己接受这个区块的方法是：在创建下一个区块时，把被接受区块的 hash 当做新区块之前的 hash 使用。\n\n如果有两个节点同时向网络广播了两个不同版本的“下一区块”，并且部分节点接收到了其中一个，部分节点接收到了另外一个，这就会导致区块链出现了短暂的分支。目前的处理方式是：节点会先处理最先接收到的链，同时也会把另一个合法链保存下来。当下一个工作证明被找到后，一定会有一个分支成为最长链，这个分歧就会被打消。\n新的交易并不一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。\n6. 奖励 Incentive\n按照上面提到的约定，每个区块的第一笔交易都是一个特殊的交易，因为它会从无到有生成一枚新的硬币，所有权属于这个区块的生成者。这意味着节点网络的支持者可以从中获取奖励。这就好比黄金的采矿者在消耗能源和设备等资源不断产生新的黄金并获取奖励一样，BTC 的“矿工”也在消耗 CPU 工作时间和电力等资源“挖取” BTC 增量（也就是他们收到的奖励）。\n此外，奖励也可以从交易额中抽成。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来奖励节点把该交易打包进此区块的。一旦既定数量的硬币已经进入流通，那么奖励将全面交由交易手续费来完成，且绝对不会有通货膨胀，因为这一奖励机制不会带来新的 BTC。\n另外，奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。\n7. 回收硬盘空间 Reclaiming Disk Space\n为了节省磁盘的空间占用，如果一枚硬币最近发生的交易是足够早以前的，这一般意味着是在足够多的区块以前，那么这笔交易之前该币的交易记录可以被丢弃，相当于将这一部分交易记录归档。为了在不破坏该区块的哈希的前提下实现此功能，交易记录的哈希将被纳入一个 Merkle 树之中，而只有树根被纳入该区块的哈希之中。通过剪枝方法，老区块即可被压缩。内部的哈希并不需要被保存。\n\n\n一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。\n8. 简化版支付确认 Simplified Payment Verification\n即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的最长链的区块头拷贝 —— 他可以通过查询在线节点确认自己拥有的确实来自最长链 —— 而后获取 Merkle 树的树枝节点，进而连接到这个区块被打上时间戳时的交易。用户并不能自己检查交易，但，通过连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。\n\n\n只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。\n9. 价值的组合与分割 Combining and Splitting Value\n尽管现在的架构确实支持逐个地处理每一枚硬币，但是为每最小单位的硬币设置一条单独的记录是一件很笨拙的事情。为了允许价值的分割和合并，交易记录可以包含多条输入和输出。一般情况下，要么是一个单独的来自于一个相对大的之前的交易的输入，要么是很多个输入来自于更小金额的组合；与此同时，最多有两个输出：一个是支付（指向收款方），如果必要的话，另外一个是找零（指向发款方）。\n\n\n10. 隐私 Privacy\n在传统的银行模型中，交易者双方的隐私是交由受信任的第三方（也就是银行）维护的。但是 BTC 的理念是交易记录的完全公开，因此传统的办法无法在此处使用。但是，依然可以通过“公钥匿名”的方式来维持隐私。换而言之，就是公众可以看到某人向另一个人转账了一定的金额，但是，没有任何信息指向某个确定的人。\n\n\n还有另外一层防火墙。交易者应该针对每一笔交易启用一对新的公私钥，以便他人无法将这些交易追溯到同一个所有者身上。有些多输入的交易依然难免被追溯，因为那些输入必然会被识别出来自于同一个所有者。危险在于，如果一个公钥的所有者被曝光之后，与之相关的所有其他交易都会被曝光。\n11. 计算 Calculation\n假设这样一个场景：某一位攻击者正在试图声称一个比诚实链更快的替代链。就算他成功了，也不能对系统做任意的修改，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。\n诚实链和攻击者之间的竞争可以用二项式随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了。\n攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率，如下：\n\n\n既然我们已经假定 p &gt; q，由于攻击者需要赶超的区块数量越来越多，其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地向前猛跨一步，那么他的胜率将在他进一步落后的同时消弭殆尽。\n现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。\n收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。\n收款人等到此笔交易被打包进区块，并已经有z个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是可以假定诚实区块在每个区块生成过程中耗费的平均时间；攻击者的潜在进展符合泊松分布，其期望值为： \n为了算出攻击者依然可以赶上的概率，我们要把攻击者需要追赶的区块数目的帕松分布概率密度，乘以在落后该区块数目下能够追上来的概率：  为了避免对分布的无限尾部进行求和，进行重排如下：  上述运算过程可以转化成如下 C 语言代码：\n#include &lt;math.h&gt;\ndouble AttackerSuccessProbability(double q, int z) {\n  double p = 1.0 - q;\n  double lambda = z * (q / p);\n  double sum = 1.0;\n  int i, k;\n  for (k = 0; k &lt;= z; k++) {\n    double poisson = exp(-lambda);\n    for (i = 1; i &lt;= k; i++)\n    poisson *= lambda / i;\n    sum -= poisson * (1 - pow(q / p, z - k));\n    }\n    return sum;\n}\n获取部分结果，我们可以看到概率随着z的增加指数级下降：\n \n如果 P 小于 0.1%，则有：\n \n12. 结论 Conclusion\n本文提出了一个不必依赖信任的电子交易系统；起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，本文提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。\n这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。\n","slug":"Bitcoin-白皮书阅读手记","date":"2025-04-03T03:20:24.000Z","categories_index":"BlockChain","tags_index":"BlockChain","author_index":"Chujun Xiang"},{"id":"c5d49efbe59ab9c6266a30eec8df7a97","title":"提示工程简介与方法概述","content":"简介\n提示工程（Prompt Engineering）是一门较新的学科，关注提示词开发和优化，帮助用户将大语言模型（Large Language Model, LLM）用于各场景和研究领域。\n意义 掌握了提示工程相关技能将有助于用户更好地了解大型语言模型的能力和局限性。研究人员可利用提示工程来提升大语言模型处理复杂任务场景的能力，如问答和算术推理能力。开发人员可通过提示工程设计、研发强大的工程技术，实现和大语言模型或其他生态工具的高效接轨。\n误区 提示工程不仅仅是关于设计和研发提示词。它包含了与大语言模型交互和研发的各种技能和技术。提示工程在实现和大语言模型交互、对接，以及理解大语言模型能力方面都起着重要作用。用户可以通过提示工程来提高大语言模型的安全性，也可以赋能大语言模型，比如借助专业领域知识和外部工具来增强大语言模型能力。\n提示词的基本要素\n指令：想要模型执行的特定任务或指令。\n上下文：包含外部信息或额外的上下文信息，引导语言模型更好地响应。\n输入数据：用户输入的内容或问题。\n输出指示：指定输出的类型或格式。\n提示词的通用技巧\n从简入繁：当有一个涉及许多不同子任务的大任务时，可以尝试将任务分解为更简单的子任务，并随着获得更好的结果而不断构建。这避免了在提示设计过程中一开始就添加过多的复杂性。\n指令化操作：可以使用命令来指示模型执行各种简单任务，例如“写入”、“分类”、“总结”、“翻译”、“排序”等，从而为各种简单任务设计有效的提示。可以使用一些清晰的分隔符，如“###”，来分隔指令和上下文。举例：\nPrompt：\n### 指令 ###\n将以下文本翻译成西班牙语：\n文本：“hello！”\n\nOutput：\n¡Hola!\n提高具体性： 提示越具体和详细，结果就越好。可以通过提供示例、格式、描述性提示等方式来强化输出。此外，还需要考虑 Prompt 长度（因为这个是受限制的），所以需要在这点和细节之间做好取舍。举例：\nPrompt:\n提取以下文本中的地名。\n所需格式：\n地点：&lt;逗号分隔的公司名称列表&gt;\n输入：“虽然这些发展对研究人员来说是令人鼓舞的，但仍有许多谜团。里斯本未知的香帕利莫德中心的神经免疫学家Henrique Veiga-Fernandes说：“我们经常在大脑和我们在周围看到的效果之间有一个黑匣子。”“如果我们想在治疗背景下使用它，我们实际上需要了解机制。””\n\nOutput:\n地点：里斯本，香帕利莫德中心\n保持精确性：在提高具体性和采用了指令化等操作之后，很容易导致 Prompt 的目的变得不明确甚至是被混淆，换而言之，就是过多的辅助提示词影响了 LLM 对 Prompt 意图的理解。因此需要保持 Prompt 的直接性和适当的简洁性。\n强调需要做的事：设计 Prompt 时的另一个常见技巧是避免说不要做什么，而是说要做什么。这鼓励更具体化，并关注导致模型产生良好响应的细节。举例：\nPrompt1:\n以下是向客户推荐电影的代理程序。不要询问兴趣。不要询问个人信息。\n顾客：请根据我的兴趣推荐电影。\n客服：\n\nOutput1:\n当然，我可以根据您的兴趣推荐电影。您想看什么类型的电影？您喜欢动作片、喜剧片、爱情片还是其他类型的电影？\n\nPrompt2:\n以下是向客户推荐电影的代理程序。客服负责从全球热门电影中推荐电影。它应该避免询问用户的偏好并避免询问个人信息。如果代理没有电影推荐，它应该回答“抱歉，今天找不到电影推荐。”。\n顾客：请根据我的兴趣推荐一部电影。\n客服：\n\nOutput2:\n抱歉，我没有关于您兴趣的任何信息。不过，这是目前全球热门的电影列表：[电影列表]。希望您能找到喜欢的电影！\n常见提示技术\nZero-Shot\n零样本提示即为：不事先给 LLM 提供样例，而直接将问题给出。示例如下：\nPrompt:\n将文本分类为中性、负面或正面。\n文本：我认为这次假期还可以。\n情感：\n\nOutput:\n中性\nFew-Shot\n虽然大型语言模型展示了惊人的零样本能力，但在使用零样本设置时，它们在更复杂的任务上仍然表现不佳。基于此原因，少样本提示可以作为一种技术，以启用上下文学习 (In-Context Learning) 并引导模型实现更好的性能，示例如下：\nPrompt:\nA &quot;whatpu&quot; is a small, furry animal native to Tanzania. An example of a sentence that uses\nthe word whatpu is:\nWe were traveling in Africa and we saw these very cute whatpus.\nTo do a &quot;farduddle&quot; means to jump up and down really fast. An example of a sentence that uses\nthe word farduddle is:\n\nOutput:\nWhen we won the game, we all started to farduddle in celebration.\nPrompt:\nThis is awesome! // Negative\nThis is bad! // Positive\nWow that movie was rad! // Positive\nWhat a horrible show! //\n\nOutput:\nNegative\n标准的少样本提示对许多任务都有效，但仍然不是一种完美的技术，特别是在处理更复杂的推理任务的时候，例子如下：\nPrompt:\n这组数字中的奇数加起来是一个偶数：4、8、9、15、12、2、1。\nA：答案是False。\n这组数字中的奇数加起来是一个偶数：17、10、19、4、8、12、24。\nA：答案是True。\n这组数字中的奇数加起来是一个偶数：16、11、14、4、8、13、24。\nA：答案是True。\n这组数字中的奇数加起来是一个偶数：17、9、10、12、13、4、2。\nA：答案是False。\n这组数字中的奇数加起来是一个偶数：15、32、5、13、82、7、1。\nA：\n\nOutput:\n答案是True。\n显然这个答案是不靠谱的，在涉及较为复杂的问题时，可能需要经历多个推理步骤才能得到最终结果，因此我们需要更加合适的激励策略。\nChain-of-Thought (CoT)\nChain-of-Thought (CoT) 是一种改进的激励策略，用于提高 LLM 复杂推理任务上的性能，如算术推理、常识推理和符号推理。与 ICL 中简单地使用输入-输出对构造提示不同，CoT 合并了中间推理步骤，可以将最终输出引入提示中。\n对于上面的问题，可以参考 CoT 的思路对 Prompt 进行调整：\nPrompt:\n这组数中的奇数加起来是偶数：4、8、9、15、12、2、1。\nA：将所有奇数相加（9、15、1）得到25。答案为False。\n这组数中的奇数加起来是偶数：15、32、5、13、82、7、1。\nA：\n\nOutput:\n将所有奇数相加（15、5、13、7、1）得到41。答案为False。\n可以看到 LLM 给出了我们所期望的正确回复。\nLet’s think step by step\n这是一种特殊的零样本 CoT 方法，举例如下：\nPrompt1:\n我去市场买了10个苹果。我给了邻居2个苹果和修理工2个苹果。然后我去买了5个苹果并吃了1个。我还剩下多少苹果？\n\nOutput1:\n11个苹果\n\n\nPrompt2：\n我去市场买了10个苹果。我给了邻居2个苹果和修理工2个苹果。然后我去买了5个苹果并吃了1个。我还剩下多少苹果？\n让我们逐步思考。\n\nOutput2：\n首先，您从10个苹果开始。\n您给了邻居和修理工各2个苹果，所以您还剩下6个苹果。\n然后您买了5个苹果，所以现在您有11个苹果。\n最后，您吃了1个苹果，所以您还剩下10个苹果。\nSelf-Consistency\n自我一致性方法的基本宗旨是通过少样本 CoT 采样多个不同的推理路径，并使用生成结果选择最一致的答案。这有助于提高CoT提示在涉及算术和常识推理的任务中的性能。示例如下：\nPrompt:\nQ：林中有15棵树。林业工人今天将在林中种树。完成后，将有21棵树。林业工人今天种了多少棵树？\nA：我们从15棵树开始。后来我们有21棵树。差异必须是他们种树的数量。因此，他们必须种了21-15 = 6棵树。答案是6。\nQ：停车场有3辆汽车，又来了2辆汽车，停车场有多少辆汽车？\nA：停车场已经有3辆汽车。又来了2辆。现在有3 + 2 = 5辆汽车。答案是5。\nQ：Leah有32块巧克力，她的姐姐有42块。如果他们吃了35块，他们总共还剩多少块？\nA：Leah有32块巧克力，Leah的姐姐有42块。这意味着最初有32 + 42 = 74块巧克力。已经吃了35块。因此，他们总共还剩74-35 = 39块巧克力。答案是39。\nQ：Jason有20个棒棒糖。他给Denny一些棒棒糖。现在Jason只有12个棒棒糖。Jason给Denny多少棒棒糖？\nA：Jason有20个棒棒糖。因为他现在只有12个，所以他必须把剩下的给Denny。他给Denny的棒棒糖数量必须是20-12 = 8个棒棒糖。答案是8。\nQ：Shawn有五个玩具。圣诞节，他从他的父母那里得到了两个玩具。他现在有多少个玩具？\nA：他有5个玩具。他从妈妈那里得到了2个，所以在那之后他有5 + 2 = 7个玩具。然后他从爸爸那里得到了2个，所以总共他有7 + 2 = 9个玩具。答案是9。\nQ：服务器房间里有9台计算机。从周一到周四，每天都会安装5台计算机。现在服务器房间里有多少台计算机？\nA：从周一到周四有4天。每天都添加了5台计算机。这意味着总共添加了4 * 5 =\n20台计算机。一开始有9台计算机，所以现在有9 + 20 = 29台计算机。答案是29。\nQ：Michael有58个高尔夫球。星期二，他丢失了23个高尔夫球。星期三，他又丢失了2个。星期三结束时他还剩多少个高尔夫球？\nA：Michael最初有58个球。星期二他丢失了23个，所以在那之后他有58-23 = 35个球。星期三他又丢失了2个，所以现在他有35-2 = 33个球。答案是33。\nQ：Olivia有23美元。她用每个3美元的价格买了五个百吉饼。她还剩多少钱？\nA：她用每个3美元的价格买了5个百吉饼。这意味着她花了5\nQ：当我6岁时，我的妹妹是我的一半年龄。现在我70岁了，我的妹妹多大？\nA：\n\nOutput1:\n当我6岁时，我的妹妹是我的一半年龄，也就是3岁。现在我70岁了，所以她是70-3 = 67岁。答案是67。\n\nOutput2:\n当叙述者6岁时，他的妹妹是他年龄的一半，也就是3岁。现在叙述者70岁了，他的妹妹应该是70-3 = 67岁。答案是67。\n\nOutput3:\n当我6岁时，我的妹妹是我的一半年龄，也就是3岁。现在我70岁了，所以她是70/2 = 35岁。答案是35。\nTree of Thoughts (ToT)\n对于需要探索或预判战略的复杂任务来说，传统或简单的提示技巧是不够的。最近有研究者提出了思维树（Tree of Thoughts，ToT）框架，该框架基于思维链提示进行了总结，引导语言模型探索把思维作为中间步骤来解决通用问题。\n可以用下面一张图来说明白这几种 Prompt 技巧的关系与区别： \nReference\n提示工程指南：https://www.promptingguide.ai/zh\n","slug":"提示工程简介与方法概述","date":"2023-07-27T07:41:55.000Z","categories_index":"LLM,Prompt Engineering","tags_index":"LLM,Prompt Engineering","author_index":"Chujun Xiang"},{"id":"ab58292848b10dce6b1c694b6eb9b247","title":"Hi there!","content":"Are you watching? Welcome to my website, here I’ll update some blogs and pieces of thoughts.\n","slug":"Greetings","date":"2023-07-27T02:46:39.000Z","categories_index":"","tags_index":"碎碎念","author_index":"Chujun Xiang"}]